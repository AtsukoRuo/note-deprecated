## 分治法

[TOC]



## 概述

分治法有以下三个基本步骤：

- **分解（Divide）**：将问题划分为多个输入规模更小的、性质与原问题相同的、相对独立的子问题
- **解决（Conquer）**：若子问题规模较小且易于解决时，则直接解。否则，继续Divide。
- **合并（Combine）**：将各子问题的解合并为原问题的解。

为了分析分治算法运行时间，我们需要一种数学工具——**递归（推）（Recurrence）**。递归就是一个等式或者不等式，它使用函数本身去刻画一个定义在整数或者实数上的函数。它通常包含多种情况，用分段函数形式去描述即可。如果一种情况下包含了递归调用，那么称这种情况为**递归情况（recursive case）**，否者称之为**基本情况（base case）**。如果一个递归是**良好定义的（well defined）**，那么至少存在一个具体的函数表达式使得递归成立，否则就是**定义不明确（ill defined）**。



如果一个递归满足以下性质，那么我们可以用它刻画算法的运行时间，并且称之为**算法的（algorithmic）**。

对于任意充分大的常量$n_0 > 0$，我们有

- 对于任意$n < n_0$，我们有$T(n) = \Theta(1)$
- 对于任意$n \geq n_0$，经过有限步递归调用，每一个递归路径都可以到达基本情况。

> Proof：性质1表明，$\exist c_1,c_2 : 0 < c_1 \leq T(n) \leq c_2$。令$c_1$为该算法调用函数的最小开销，令$c_2$为该算法在$n < n_0$的输入规模下解决问题所花费的最大开销（注：因为输入规模已限定，所以此时解决问题的开销已明确）。对于性质2，假设递归不满足但仍可以刻画算法的运行时间，那么就表明算法可以无限次迭代，即算法是不正确的，所以假设不成立。



对于递归，我们采用以下约定

- 我们总是忽视递归的基本情况，这样就不用考虑$n_0$的选取。此外，虽然改变基本情况的结果会影响到递归式的精确解，但是误差可能不超过一个常量因子。**完整的证明需要考虑基本情况**。
- 求解形如$T(n) \leq 2T(n/2) +\Theta(n)$的递归，我们用$\Omicron$表示解答。
- 求解递归式时，我们可以忽略向下取整、向上取整。

可以从经验或者有关定理来判断忽视这些细节是否对结果有较大影响。



下面通过一些式子说明分治法与递归的关系：
$$
\begin{aligned}
T(n) &= 8T(n/2) + \Theta(1) \\
T(n) &= 7T(n/2) + \Theta(n^2)\\
T(n) &= T(n/5) + T(7n/10) + \Theta(n) \\
T(n) &= T(n - 1) + \Theta(1)
\end{aligned}
$$


有以下方法来求解递归

- 代替法（substitution method）
- 递归树（recursion-tree method）
- 主方法（master method）
- `Akra-Bazzi` 方法

## 案例研究：矩阵乘法（Matrix multiply）

注意：这里我们考虑的矩阵乘法是 $C = C+AB$，而不是$C = AB$

### 暴力求解法



### 基于分治思想的算法



实现该算法时，无需拷贝元素到临时数组中，可以考虑用索引法。

### Strassen算法



## 案例研究 ：最大子数组



## 代替法



## 递归树

## 主方法

## Akra-Bazzi

