# RTTI

[TOC]

RTTI （RunTime Type Information，运行时类型信息）能够在程序运行时发现并使用类型的信息，在Java中有两种方式实现RTTI机制：

- 传统的RTTI，假定我们在编译时已经知道类的类型。
- 反射机制，允许我们在运行时发现和使用类的信息。



## 传统的RTTI

RTTI有三种形式

- class对象
- 强制转型
- instanceof：它返回一个布尔值，告诉我们对象是不是某个特定类型的实例。允许向上转型。同时Class对象有public boolean isInstance(Object o);用于判断对象o是否属于该类型。



### class对象

一个对象的创建包括以下三个步骤：

- 加载：这是由加载器负责的。在调用某个类时（存疑），类加载器首先会检查这个类的 `Class` 对象是否已经加载到内存，如果尚未加载，默认的类加载器就会根据类名查找 `.class` 文件，将文件（字节码）加载到内存中。一旦某个类的 `Class` 对象被载入内存，它就可以用来创建这个类的所有对象。因此，每个类都有一个相应的Class对象。

	- Java虚拟机有类加载器系统，用于创建对象。该系统包含若干个类加载器并按照顺序调用（类加载器链）。其中有一个原生类加载器，用于加载可信类（例如 Java API类）。如果您有特殊的需求（例如，从数据库中获取Class对象），可以外挂一个自定义的加载器。因此，Java 程序在它开始运行之前并没有被完全加载，很多部分是在需要时才会加载。
	- 当程序创建第一个对类的静态成员的引用时，就会加载这个类。其实构造器也是类的静态方法，虽然构造器前面并没有 `static` 关键字。

	

- 链接：这个类的字节码被加载后，JVM 会对其进行安全验证，确保它没有损坏，并且不包含恶意代码。然后为static字段分配存储空间。

- 初始化：正常的初始化流程。尽可能满足惰性初始化。



获取class对象的方法：

- 调用`Class.forName()`静态方法。

- 在对象实例上调用`getClass()`方法来获取一个Class对象的引用，注意Class对象并不与类的对象绑定，而是与类本身绑定。

- 类字面常量，例如`A.class`。它有两点值得说明

	- 当使用类字面常量时，类初始化并不会执行。这点与forName不同。此后可以通过`newInstance()` 方法产生类的对象，该类必须有无参构造器。

	- 如果访问访问类的final static字段时，可用使用

		~~~java
		Class initable = Initable.class;
		Initable.STATIC_FINAL
		~~~

		这样可以获取值，而不是Class对象，同样不会进行初始化。



~~~java
Class c = Class.forName("className");			//该方法有副作用，即会隐式加载类。

A a = new A;
Class c1 = a.getClass();

Class c2 = A.class
Class c3 = Long.TYPE		//另外，对于基本数据类型的包装类，还有一个标准字段 TYPE
Class c4 = long.class
~~~



推荐使用泛型版本的Class类，这样可以进行类型检查。





## 反射

